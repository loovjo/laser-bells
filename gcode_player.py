import midi_parser
import random

class GCodeMachineException(Exception):
    pass

class MoveOutOfBounds(GCodeMachineException):
    def __init__(self, pos, dim):
        self.pos = pos
        self.dim = dim
        self.message = f"Machine out of bounds! Wanted to move to {pos}, but dimensions is {dim}"
        super().__init__(self.message)

HZ2FR = 3.033
SLOWDOWN = 0.8

def tone_to_g1(fq1, fq2, t):
    t /= SLOWDOWN
    # fq1, fq2 in hertz, t in seconds
    # Gives (feedrate, dx, dy)

    fr1, fr2 = fq1 * HZ2FR, fq2 * HZ2FR

    dia_speed = (fr1 ** 2 + fr2 ** 2) ** 0.5

    t_min = t / 60

    return (dia_speed, fr1 * t_min, fr2 * t_min)


class GCodeMachine:
    def __init__(self, width, height):
        self.gcode = ""
        self.position = (0, 0)
        self.dimensions = (width, height)
        self.wanted_position = (0, 0)

    def setup(self):
        self.do_gcode("# Generated by laser-bells <github.com/loovjo/laser-bells>") # Absolute programming
        self.do_gcode("G90") # Absolute programming
        self.do_gcode("G21") # Millimeters
        self.do_gcode("G28") # Auto home

    def finalize(self):
        self.do_gcode("M02") # Done?

    def do_gcode(self, gcode_line):
        self.gcode += gcode_line + "\n"

    def move_to(self, fr, x, y):
        if 0 <= x < self.dimensions[0] and 0 <= y < self.dimensions[1]:
            self.do_gcode(f"G1 F{fr:.5f} X{x:.5f} Y{y:.5f}")
            self.position = (x, y)
        else:
            raise MoveOutOfBounds((x, y), self.dimensions)

    def tone(self, fq1, fq2, t):
        if fq1 == fq2 == 0:
            # delay
            if t > 1:
                self.do_gcode(f"G4 S{int(t)} P{int(1000*(t%1))}")
            else:
                self.do_gcode(f"G4 P{int(1000*(t%1))}")
            return

        fr, dx, dy = tone_to_g1(fq1, fq2, t)
        # if random.random() < 0.5:
        #     dx, dy = dy, dx

        if self.position[0] > self.wanted_position[0]:
            dx *= -1

        if self.position[1] > self.wanted_position[1]:
            dy *= -1

        if abs(self.position[0] - self.wanted_position[0]) < abs(dx) or abs(self.position[1] - self.wanted_position[1]) < abs(dx):
            self.wanted_position = (random.random() * self.dimensions[0], random.random() * self.dimensions[1])


        try:
            self.move_to(fr, self.position[0] + dx, self.position[1] + dy)
        except MoveOutOfBounds as e:
            if t < 0.01:
                print("At", self.position, "dxdy=", dx, dy)
                print(e)
                exit()
            else:
                self.tone(fq1, fq2, t / 2)
                self.tone(fq1, fq2, t / 2)


SONG = "MIDI-Samples/electric.mid"
TS = 4

voice_1 = [(0, 0)] # midi_parser.read_midi(SONG, 0, 0, use_min=False, ts=TS)
voice_2 = midi_parser.read_midi(SONG, 1, 0, use_min=True, ts=TS)
last_time = max(voice_1[-1][0], voice_2[-1][0])

voice_1.insert(0, (0, 0))
voice_2.insert(0, (0, 0))
voice_1.append((last_time + 1, 0))
voice_2.append((last_time + 1, 0))


melody = []

i, j = 0, 0
t = 0
while i < len(voice_1) - 1 and j < len(voice_2) - 1:
    if voice_1[i+1][0] - t < voice_2[j+1][0] - t:
        melody.append((voice_1[i][1], voice_2[j][1], voice_1[i + 1][0] - t))
        t = voice_1[i + 1][0]
        i += 1
    else:
        melody.append((voice_1[i][1], voice_2[j][1], voice_2[j + 1][0] - t))
        t = voice_2[j + 1][0]
        j += 1



# print(len(melody))

machine = GCodeMachine(375, 315)
machine.setup()

for fq1, fq2, t in melody:
    machine.tone(fq1, fq2, t)

machine.finalize()

print(machine.gcode)
